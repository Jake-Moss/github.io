{"0": {
"doc":  "Algorithms &amp; Data Structures",
"title": "Algorithms &amp; Data Structures",
"content": "Table of Contents . | 1. Topics | . 1. Topics . | | | .",
"url": "/notes/20211109220012-algorithms_data_structures"
},"1": {
"doc":  "Asymptotic Analysis",
"title": "Asymptotic Analysis",
"content": "Table of Contents . | 1. Growth rates | 2. Big O notation family . | 2.1. Big O | 2.2. Big Omega | 2.3. Big Theta | . | . 1. Growth rates . 2. Big O notation family . 2.1. Big O . | Big-O notation describes an upper bound on a function \\(f(n)\\) is \\(O(g(n))\\) if \\(f(n)\\) is asymptotically less than or equal to \\(g(n)\\) | That is, . Given functions \\(f(n)\\) and \\(g(n)\\), we say that \\(f(n)\\) is \\(O(g(n))\\) if there exists some positive \\(c,n_0\\) such that \\(f(n) \\leq c \\cdot g(n), \\quad \\forall n \\geq n_0\\) . | . 2.2. Big Omega . | Big-Omega notation describes a lower bound on a function | \\(f(n)\\) if \\(\\Omega(g(n))\\) if \\(f(n)\\) is asymptotically greater than or equal to \\(g(n)\\) | That is, . Given functions \\(f(n)\\) and \\(g(n)\\), we say that \\(f(n)\\) is \\(\\Omega(g(n))\\) if there exists some positive \\(c,n_0\\) such that \\(f(n) \\geq c \\cdot g(n), \\quad \\forall n \\geq n_0\\) . | . 2.3. Big Theta . | Big-Theta notation describes a tight bound on a function (if one exists) \\(f(n)\\) is \\(\\Theta(g(n))\\) if \\(f(n)\\) is asymptotically equal to \\(g(n)\\) | That is, . Given functions \\(f(n)\\) and \\(g(n)\\), we say that \\(f(n)\\) is \\(\\Theta(g(n))\\) if there exists some positive \\(c_1,c_2,n_0\\) such that \\(c_1 \\cdot g(n) \\leq f(n) \\leq c_2 \\cdot g(n), \\quad \\forall n \\geq n_0\\) . | Informally, \\(f(n)\\) is \\(\\Theta(g(n))\\) if it is both \\(O(g(n))\\) and \\(\\Omega(g(n))\\) | .",
"url": "/notes/20211109222410-asymptotic_analysis"
},"2": {
"doc":  "Sorting Algorithms",
"title": "Sorting Algorithms",
"content": "Table of Contents . | 1. Merge sort | 2. Quick sort | 3. Selection sort | 4. Insertion sort | 5. Bucket sort . | 5.1. Analysis | . | 6. Radix sort | . 1. Merge sort . Runs in \\(O(n \\log n)\\) time . | Sequential data access (cache hits) | fast (good for huge inputs) | . \\[T(n) = \\begin{cases} O(1) &amp; n Algorithm mergeSort(A,l,r) Input an array A Output A sort between indicies l and r if l &amp;lt; r m &amp;lt;- floor((l + r) / 2) mergeSort(S, l, m) mergeSort(S, m + 1, r) merge(S, l, m, r) Algorithm merge(A, l, m r) Input an array A with two sorted halves Output sorted union of A[l..m] and A[m..r] n1 &amp;lt;- m – l + 1 // size of first half of A n2 &amp;lt;- r – m // size of second half of A L &amp;lt;- copy of A[l..m], R &amp;lt;- copy of A[m..r] i &amp;lt;- 0, j &amp;lt;- 0, k &amp;lt;- l while i &amp;lt; n1 and j &amp;lt; n2 do // merge into A if L[i] &amp;lt;= R[j] then A[k++] = L[i++] else A[k++] = R[j++] while i &amp;lt; n1 do // copy rest of L into A A[k++] = L[i++] while j &amp;lt; n2 do // copy rest of R into A A[k++] = R[j++] . 2. Quick sort . Runs in \\(O(n \\log n)\\) expected time . | in-place (not really because of call stack) | randomised (or not, it depends) | fastest (good for large inputs ) | . 3. Selection sort . Run in \\(O(n^2)\\) time . | in-place | slow (good for small inputs though) | . 4. Insertion sort . Run in \\(O(n^2)\\) time . | in-place | slow (good for small inputs though) | . 5. Bucket sort . Runs in \\(O(n + N)\\) time . Algorithm bucketSort(S): Input sequence S of n entries with integer keys in the range [0, N − 1] Output sequence S sorted in nondecreasing order of the keys B &amp;lt;- array of N empty sequences for each entry e in S do k &amp;lt;- key of e remove e from S insert e at the end of bucket B[k] for i &amp;lt;- 0 to N−1 do for each entry e in B[i] do remove e from B[i] insert e at the end of S . 5.1. Analysis . | Initialising the bucket array takes O(N) time | Phase 1 takes \\(O(n)\\) time | Phase 2 takes \\(O(n + N)\\) time | . 6. Radix sort . Runs in \\(O(n \\cdot d)\\) time. Where \\(d\\) is the length of the key. | stable | fastest (with constrains on keys) | .",
"url": "/notes/20211110133306-sorting_algorithms"
},"3": {
"doc":  "Trees",
"title": "Trees",
"content": "Table of Contents . | 1. Terminology and definitions . | 1.1. Binary trees | 1.2. Heap | 1.3. Binary Search Tree . | 1.3.1. Insertion | 1.3.2. Deletion | . | 1.4. AVL Tree | . | . 1. Terminology and definitions . | Height of a tree is the length of the path from root of that tree to its farthest node (i.e. leaf node farthest from the root). A tree with only root node has height \\(0\\) and a tree with zero nodes would be considered as empty. An empty tree has height of \\(-1 \\) | . 1.1. Binary trees . | Each internal node has at most two children | Exactly two for proper binary tree | Level \\(l\\) is full is it contains \\(2^l\\) nodes | A tree is complete if, for height \\(h\\), levels \\(0\\dots h -1\\) are full and level \\(h\\) all leaf nodes are as far left as possible | Height-Balance property: for every internal node \\(v\\), the heights of the children of \\(v\\) differ by at most \\(1\\) | . 1.2. Heap . Good for implementing . | Must be complete binary tree | Heap-Order: For every internal node other than the root \\(key(v) \\geq key(parent(v))\\) | Last node of a heap is the rightmost node of maximum depth | A heap storing \\(n\\) keys has height \\(O(log n)\\) | Insertion algorithm . | Find the insertion node \\(z\\) new last node | Store \\(k\\) at z | Restore the heap-order property | . | Upheap swaps \\(k\\) along an upward path from the insertion node, until \\(k\\) reaches the root or a node whose parent has a key less than or equal to \\(k\\) | Removal algorithm . | Replace the root key with the key of the last node \\(w\\) | Remove \\(w\\) | Restore the heap-order property | . | Downheap replaces root key with key \\(k\\) of the last node and swaps key \\(k\\) along a downward path from the root . | If a node has no right child, choose the left child | If a node has both children, choose the one with the smallest key | . | Insertion heap construction runs in \\(O(n \\log n)\\) time | Bottom-up heap construction runs in \\(O(n)\\) time | . 1.3. Binary Search Tree . Binary tree storing keys (or key-value entries) at its internal nodes and satisfying the following property . | Let \\(u\\), \\(v\\) and \\(w\\) be three nodes such that \\(u\\) is in the left subtree of \\(v\\) and \\(w\\) is in the right subtree of \\(v\\). Such that \\(key(u) \\leq key(v) \\leq key(w)\\) | In-order traversal of a binary search tree visits the keys in increasing order | External nodes do not store items | Search for key \\(k\\) . | Trace a downward path starting at the root | Next node visited depends on the comparison of \\(k\\) with the key of the current node . | If a leaf is reached, the key is not found | . | . | . Algorithm TreeSearch(k, v): if T.isExternal(v) return v if k &amp;lt; key(v) return TreeSearch(k, left(v)) else if k = key(v) return v else { k &amp;gt;key(v) } return TreeSearch(k, right(v)) . 1.3.1. Insertion . put(k, o) . | Search for key k . | Using TreeSearch | . | Assume \\(k\\) is not already in the tree . | \\(w\\) is the leaf reached by the search | . | Insert \\(k\\) at node \\(w\\) and expand \\(w\\) into an internal node | . 1.3.2. Deletion . remove(k) . | Search for key k . | Using TreeSearch | . | Assume key k is in the tree . | \\(v\\) is the node storing k | . | If node \\(v\\) has a leaf child \\(w\\) . | Remove \\(v\\) and \\(w\\) with removeExternal(w) . | Removes \\(w\\) and its parent | . | . | . Consider the case where the key \\(k\\) to be removed is stored at a node \\(v\\) whose children are both internal . | Find internal node \\(w\\) that follows \\(v\\) in an in-order traversal | Copy \\(key(w)\\) into node \\(v\\) | Remove node \\(w\\) and its left child \\(z\\) . | \\(w\\) must be a leaf | . | . 1.4. AVL Tree . Balanced binary search tree . | Height of an AVL tree storing \\(n\\) keys is \\(O(log n)\\) | Insertion is as in a binary search tree | .",
"url": "/notes/20211110204353-trees"
},"4": {
"doc":  "Adaptable Priority Queues",
"title": "Adaptable Priority Queues",
"content": "| Method | Unsorted | List | Sorted list | Heap | . | size, isEmpty | O(1) | O(1) | O(1) | O(1) | . | insert | O(1) | O(n) | O(n) | O(log n) | . | min | O(n) | O(1) | O(1) | O(1) | . | removeMin | O(n) | O(1) | O(1) | O(log n) | . | remove | O(1) | O(1) | O(1) | O(log n) | . | replaceKey | O(1) | O(n) | O(n) | O(log n) | . | replaceValue | O(1) | O(1) | O(1) | O(1) | .",
"url": "/notes/20211110210942-adaptable_priority_queue"
},"5": {
"doc":  "Lambda Calculus",
"title": "Lambda Calculus",
"content": "Table of Contents . | 1. What is Lambda Calculus | 2. Lambda terms | 3. Reduction rules . | 3.1. \\(\\alpha\\)-conversion: changing bound variables; | 3.2. \\(\\beta\\)-reduction: applying functions to their arguments; . | 3.2.1. Precedence rules | 3.2.2. Examples from lecture slides | . | . | 4. Free and bound variables . | 4.1. Example | . | 5. \\(\\alpha\\)-equivalent | 6. Combinators | . 1. What is Lambda Calculus . | A lambda calculus is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. | . | The lambda calculus is Turing Complete because it can be used to simulate a turning machine. It was introduced by the mathematician Alonzo Church (a mentor and influence of Alan Turing) in the 1930s. | Every program in Haskell can be translated into a lambda expressions. | . 2. Lambda terms . The set of all lambda terms (or lambda expressions) is denoted by \\(\\Lambda\\) (capital \\(\\lambda\\)) and recursively generated as follows: Let \\(V\\) be the set of variables or names. | Variables \\(x \\in V \\implies x \\in \\Lambda\\), | Abstractions \\(x \\in V \\cap M \\in \\Lambda \\implies (\\lambda x.M) \\in \\Lambda\\), and | Applications \\(M, N \\in \\Lambda \\implies (M~N) \\in \\Lambda\\). | . 3. Reduction rules . 3.1. \\(\\alpha\\)-conversion: changing bound variables; . \\(\\alpha\\)-conversion, sometimes known as \\(\\alpha\\)-renaming, allows bound variable names to be changed. For example, \\(\\alpha\\)-conversion of \\(\\lambda x.x\\) might yield \\(\\lambda y.y\\). Terms that differ only by \\(\\lambda\\)-conversion are called \\(\\lambda\\)-equivalent. Frequently, in uses of lambda calculus, \\(\\lambda\\)-equivalent terms are considered to be equivalent. It is sometimes necessary to relabel when identical names are being used in separate \\(\\lambda\\)-expressions. For instance . \\begin{align*} &amp;(\\lambda x . y)[y:=x] \\\\ &amp;=\\lambda x . x \\end{align*} turned the constant function into the identify function. If we rename first we get . \\begin{align*} &amp;((\\lambda x . y)[z])[y:=x] \\\\ &amp;=(\\lambda z . y)[y:=x] \\\\ &amp;=\\lambda z .(y[y:=x]) \\\\ &amp;=\\lambda z . x \\end{align*} 3.2. \\(\\beta\\)-reduction: applying functions to their arguments; . Replacing a bound variable with an argument expression in the body of the abstraction is called \\(\\beta\\)-reduction. \\[(\\lambda x.M)E \\longrightarrow M[x:=E]\\] We aim to reduce an expression to its \\(\\beta\\)-normal form, where it cannot be reduced further. We can think of the \\(\\beta\\)-normal form as a fully executed functional program. If a term cannot be reduced to a \\(\\beta\\)-normal form it is said to be divergent. 3.2.1. Precedence rules . | Application has higher precedence than abstraction: \\(\\lambda x . A B\\) means \\(\\lambda x .(A B)\\) and not \\((\\lambda x . A) B\\) | Application is left-associative: \\(A B C\\) means \\((A B) C\\) and not \\(A(B C)\\) | Abstraction is right-associative. \\(\\lambda x . A \\lambda y . B\\) means \\((\\lambda x .(A \\lambda y . B))\\) and not \\((\\lambda x . A)(\\lambda y . B)\\) | . 3.2.2. Examples from lecture slides . | Example 15 (35/1) . \\begin{align*} \\begin{array}{ll} (\\lambda x . \\lambda y . x y y)(\\lambda a . a) b &amp; \\\\ =(\\lambda x . \\lambda y . x y y) (\\lambda a . a) (b) &amp; \\\\ \\rightarrow(\\lambda y . x y y)[x:=\\lambda a . a] b \\qquad &amp; \\beta \\text {-reduction } \\\\ =(\\lambda y .(\\lambda a . a) y y) b &amp; \\text { bind } \\\\ =(\\lambda y .(\\lambda a . a) y y) (b) &amp; \\\\ \\rightarrow((\\lambda a . a) y y)[y:=b] &amp; \\beta \\text {-reduction } \\\\ =(\\lambda a . a) b b &amp; \\text { bind } \\\\ \\rightarrow(a)[a:=b] b &amp; \\beta \\text {-reduction } \\\\ =b b &amp; \\end{array} \\end{align*} | Example 16 (37/1) . \\begin{align*} \\begin{array}{ll} (\\lambda x y . x y) ab &amp; \\\\ =(\\lambda x .(\\lambda y . x y)) ab &amp; \\\\ \\rightarrow(\\lambda y . x y)[x:=a] b \\qquad &amp; \\beta \\text { reduction } \\\\ =(\\lambda y .a y) b &amp; \\text { bind } \\\\ \\rightarrow(a y)[y:=b] &amp; \\beta \\text { reduction }\\\\ =ab \\end{array} \\end{align*} | Example 22 (40/1) This example is divergent. \\begin{align*} \\begin{array}{lr} (\\lambda x . x x)(\\lambda x . x x) &amp; \\\\ =(\\lambda y . y y)(\\lambda x . x x) \\qquad &amp; \\alpha \\text {-conversion } \\\\ \\rightarrow(y y)[y:=\\lambda x . x x] &amp; \\beta \\text {-reduction } \\\\ =(\\lambda x . x x)(\\lambda x . x x) &amp; \\end{array} \\end{align*} | Question (41/1) Reduce \\((\\lambda a . a a)(\\lambda b . b a) c\\) to its \\(\\beta\\)-normal form or show it to be divergent: . \\begin{align*} \\begin{array}{ll} (\\lambda a . a a)(\\lambda b . b a) c &amp; \\\\ =(\\lambda a . a a) (\\lambda b . b a) (c) &amp; \\\\ \\rightarrow(a a)[a:=\\lambda b . b a] c \\qquad &amp; \\beta \\text {-reduction } \\\\ =(\\lambda b . b a)(\\lambda b . b a)(c) &amp; \\text { bind } \\\\ =(\\lambda b . b a) (\\lambda b . b a) (c) &amp; \\\\ \\rightarrow(b a)[b:=\\lambda b . b a](c) &amp; \\beta \\text {-reduction } \\\\ =(\\lambda b . b a)(a)(c) &amp; \\text { bind } \\\\ =(b a)[b:=a](c) &amp; \\beta \\text {-reduction } \\\\ =(a a)(c) &amp; \\text { bind } \\\\ =a a c &amp; \\end{array} \\end{align*} | Question (42/1) Reduce the following to its \\(\\beta\\)-normal form or show it to be divergent: . \\begin{align*} \\begin{array}{ll} (\\lambda x y z . x z(y z))(\\lambda x y . y)(\\lambda x . x) &amp; \\\\ =(\\lambda x y z . x z(y z))(\\lambda m n . m)(\\lambda p . p) \\qquad &amp; \\alpha \\text {-conversion } \\\\ =(\\lambda x . \\lambda y . \\lambda z . x z(y z))(\\lambda m \\cdot \\lambda n \\cdot m)(\\lambda p \\cdot p) &amp; \\\\ =(\\lambda x \\cdot \\lambda y \\cdot \\lambda z \\cdot x z(y z)) (\\lambda m \\cdot \\lambda n \\cdot m) (\\lambda p \\cdot p) &amp; \\\\ \\rightarrow(\\lambda y \\cdot \\lambda z \\cdot x z(y z))[x:=\\lambda m \\cdot \\lambda n \\cdot m](\\lambda p \\cdot p) &amp; \\beta \\text {-reduction } \\\\ =(\\lambda y \\cdot \\lambda z \\cdot(\\lambda m \\cdot \\lambda n \\cdot m) z(y z))(\\lambda p \\cdot p) &amp; \\text { bind } \\\\ =(\\lambda y \\cdot \\lambda z \\cdot(\\lambda m \\cdot \\lambda n \\cdot m) z(y z)) (\\lambda p \\cdot p) &amp; \\\\ \\rightarrow(\\lambda z \\cdot(\\lambda m \\cdot \\lambda n \\cdot m) z(y z))[y:=\\lambda p \\cdot p] &amp; \\beta \\text {-reduction } \\\\ =(\\lambda z \\cdot(\\lambda m \\cdot \\lambda n \\cdot m) z((\\lambda p \\cdot p) z)) &amp; \\text { bind } &amp; \\\\ \\rightarrow(\\lambda z \\cdot(\\lambda n \\cdot m)[m:=z]((\\lambda p \\cdot p) z)) &amp; \\beta \\text {-reduction } \\\\ =\\lambda z \\cdot(\\lambda n \\cdot z)((\\lambda p \\cdot p) z) &amp; \\text { bind } \\\\ =\\lambda z \\cdot(\\lambda n \\cdot z) ((\\lambda p \\cdot p) z) &amp; \\\\ \\rightarrow \\lambda z \\cdot(z)[n:=(\\lambda p \\cdot p) z] &amp; \\beta \\text {-reduction } \\\\ =\\lambda z \\cdot z &amp; \\beta \\text {-reduction } \\end{array} \\end{align*} | . 4. Free and bound variables . In \\(\\lambda\\) calculus all names are local to definitions. In the function \\(\\lambda x.x\\) we say that x is &amp;ldquo;bound&amp;rdquo; since its occurrence in the body of the definition is preceded by \\(\\lambda x\\). A name not preceded by a \\(\\lambda\\) is called a &amp;ldquo;free variable&amp;rdquo;. In the expression \\((\\lambda x.xy)\\) the variable \\(x\\) is bound and y is free. In the expression \\[ (\\lambda x.x)(\\lambda y.yx) \\] the \\(x\\) in the body of the first expression from the left is bound to the first \\(\\lambda\\). The y in the body of the second expression is bound to the second \\(\\lambda\\) and the \\(x\\) is free. It is very important to notice that the \\(x\\) in the second expression is totally independent of the \\(x\\) in the first expression. Formally, the set of free variables of an expression \\(r \\in \\Lambda\\) is defined inductively: The set of \\(r\\) &amp;rsquo;s free variables, say \\(\\mathcal{F}(r)\\), is given inductively by . | \\(\\mathcal{F}(x)=\\{x\\}\\) for \\(x\\) a variable. | \\(\\mathcal{F}(\\lambda x . t)=\\mathcal{F}(t)-\\{x\\}\\) | \\(\\mathcal{F}(s t)=\\mathcal{F}(s) \\cup \\mathcal{F}(t)\\) for \\(s, t \\in \\Lambda\\) | . 4.1. Example . | \\(\\mathcal{F}(\\lambda x . x y)=\\{y\\}\\), | \\(\\mathcal{F}(\\lambda x y . x y)=\\{\\}\\). | . 5. \\(\\alpha\\)-equivalent . Two \\(\\lambda\\)-expressions that are identical after \\(\\alpha\\)-conversion (variable renaming) are called \\(\\alpha\\)-equivalent. | The following expressions are \\(\\alpha\\)-equivalent . | \\(\\lambda x.x\\) and \\(\\lambda y.y\\), | \\(\\lambda ab.ab\\) and \\(\\lambda ba.ba\\), | \\(\\lambda x.xy\\) and\\(\\lambda s.sy\\). | . | . 6. Combinators . A combinator is a \\(\\lambda\\) expression with no free variables. They are so-called because these expression serve only to combine arguments.",
"url": "/notes/20220222145500-lambda_calculus"
},"6": {
"doc":  "Church Encoding",
"title": "Church Encoding",
"content": "Table of Contents . | 1. Church Numerals . | 1.1. Arithmetic . | 1.1.1. Successor | 1.1.2. Addition | 1.1.3. Multiplication | 1.1.4. Exponentiation | 1.1.5. Predecessor | 1.1.6. Subtraction | 1.1.7. Division | . | 1.2. Logic and predicates . | 1.2.1. Booleans | 1.2.2. Logic operators . | 1.2.2.1. And | 1.2.2.2. Or | 1.2.2.3. Not | 1.2.2.4. XOR | . | . | 1.3. Predicates . | 1.3.1. IsZero | 1.3.2. Less than or equal to | 1.3.3. Equality | . | . | . In mathematics, Church encoding is a means of representing data and operators in the . The Church numerals are a representation of the natural numbers using lambda notation. The method is named for Alonzo Church, who first encoded data in the lambda calculus this way. Terms that are usually considered primitive in other notations (such as integers, booleans, pairs, lists, and tagged unions) are mapped to higher-order functions under Church encoding. The Church-Turing thesis asserts that any computable operator (and its operands) can be represented under Church encoding. In the untyped lambda calculus the only primitive data type is the function. 1. Church Numerals . Church numerals are the representations of natural numbers under Church encoding. The higher-order function that represents natural number \\(n\\) is a function that maps any function \\(f\\) to its \\(n\\)-fold composition. In simpler terms, the &amp;ldquo;value&amp;rdquo; of the numeral is equivalent to the number of times the function encapsulates its argument. \\[f^{\\circ n} = \\underbrace{f \\circ f \\circ \\dots \\circ f}_{n}\\] . All Church numerals are functions that take two parameters. Church numerals \\(0, 1, 2, \\ldots\\), are defined as follows in the . Starting with 0 not applying the function at all, proceed with 1 applying the function once, 2 applying the function twice, 3 applying the function three times, etc.: . | Number | Function expression | Lambda expression | . | 0 | \\(0~f~x=x\\) | \\(\\lambda f.\\lambda x.x\\) | . | 1 | \\(1~f~x=f~x\\) | \\(\\lambda f.\\lambda x.f\\,x\\) | . | 2 | \\(2~f~x=f~f~x\\) | \\(\\lambda f.\\lambda x.f(f\\,x)\\) | . | 3 | \\(3~f~x=f~f~f~x\\) | \\(\\lambda f.\\lambda x.f(f(f\\,x))\\) | . | \\(\\vdots\\) | \\(\\vdots\\) | \\(\\vdots\\) | . | n | \\(n~f~x = f^{n}~x\\) | \\(\\lambda f.\\lambda x. f^{\\circ n}\\,x\\) | . We call the function \\(f\\) the \\(\\mathrm{succ}\\) or 1.1.1 the function. The Church numeral 3 represents the action of applying any given function three times to a value. The supplied function is first applied to a supplied parameter and then successively to its own result. The end result is not the numeral 3 (unless the supplied parameter happens to be 0 and the function is a successor function). The function itself, and not its end result, is the Church numeral 3. The Church numeral 3 means simply to do anything three times. It is an ostensive demonstration of what is meant by &amp;ldquo;three times&amp;rdquo;. 1.1. Arithmetic . Arithmetic operations on numbers may be represented by functions on Church numerals. 1.1.1. Successor . We can define a successor function, which takes a Church numeral \\(n\\) and returns \\(n + 1\\) by adding another application of \\(f\\). \\[\\mathrm{succ} := \\lambda n.\\lambda f.\\lambda x.f(nfx)\\] . 1.1.2. Addition . Because the \\(m\\)-th composition of \\(f\\) composed with the \\(n\\)-th composition of \\(f\\) gives the \\(m+n\\)-th composition of \\(f\\), addition can be defined as follows: . \\[\\mathrm{plus} := \\lambda m.\\lambda n.\\lambda f.\\lambda x.m f(n f x)\\] . Or more intuitively . \\[\\mathrm{plus} := \\lambda m.\\lambda n.m~\\mathrm{succ}~n\\] . 1.1.3. Multiplication . Similarly, multiplication can be defined as . \\[\\mathrm{mult} := \\lambda m.\\lambda n.\\lambda f.m (n f)\\] . Alternatively, . \\[\\mathrm{mult} := \\lambda m.\\lambda n.m (\\mathrm{plus}~n)~0\\] . 1.1.4. Exponentiation . Since multiplying \\(m\\) and \\(n\\) is the same as repeating the add \\(n\\) function m times and then applying it to zero. Exponentiation has a rather simple rendering in Church numerals, namely . \\[\\mathrm{pow} := \\lambda b.\\lambda e.e~b\\] . 1.1.5. Predecessor . The predecessor function is left as an exercise for the reader and is simply stated below. \\[\\mathrm{pred} := \\lambda n . \\lambda f . \\lambda x . n(\\lambda g . \\lambda h . h(g f))(\\lambda u . x)(\\lambda u . u)\\] . A Church numeral applies a function \\(n\\) times. The predecessor function must return a function that applies its parameter \\(n - 1\\) times. This is achieved by building a container around \\(f\\) and \\(x\\), which is initialized in a way that omits the application of the function the first time. See the deviration of the predecessor function for a more detailed explanation. Note: \\(\\mathrm{pred}(0) = 0\\) . 1.1.6. Subtraction . The subtraction function can be written based on the predecessor function. \\[\\mathrm{minus} := \\lambda m.\\lambda n.(n~\\mathrm{pred})m\\] . Note: \\(\\mathrm{minus}(m, n) = 0\\) where \\(m \\leq n\\) . 1.1.7. Division . Division is also left as an exercise for the reader. See here for more information. \\begin{align*} \\mathrm{divide} := &amp;(\\lambda n.((\\lambda f.(\\lambda x.x x) (\\lambda x.f (x x)))\\\\ &amp; (\\lambda c.\\lambda n.\\lambda m.\\lambda f.\\lambda x.(\\lambda d.(\\lambda n.n (\\lambda x.(\\lambda a.\\lambda b.b))\\\\ &amp;(\\lambda a.\\lambda b.a)) d ((\\lambda f.\\lambda x.x) f x) (f (c d m f x)))\\\\ &amp; ((\\lambda m.\\lambda n.n (\\lambda n.\\lambda f.\\lambda x.n (\\lambda g.\\lambda h.h (g f))\\\\ &amp; (\\lambda u.x) (\\lambda u.u)) m) n m)))((\\lambda n.\\lambda f.\\lambda x. f (n f x)) n) \\end{align*} 1.2. Logic and predicates . 1.2.1. Booleans . Boolean logic may be considered as a choice. The Church encoding of true and false are functions of two parameters: . | \\(\\mathrm{true}\\) chooses the first parameter. | \\(\\mathrm{false}\\) chooses the second parameter. | . The two definitions are known as Church Booleans: . \\[\\mathrm{true} := \\lambda a.\\lambda b.a\\]1 . \\[\\mathrm{false} := \\lambda a.\\lambda b.b\\] . This definition allows predicates (i.e. functions returning logical values) to directly act as if-clauses. A function returning a Boolean, which is then applied to two parameters, returns either the first or the second parameter: . predicate then-clause else-clause . evaluates to then-clause if the predicate evaluates to true, and to else-clause if the predicate evaluates to false. 1.2.2. Logic operators . Because true and false choose the first or second parameter they may be combined to provide logic operators . 1.2.2.1. And . \\[\\mathrm{and} = \\lambda p.\\lambda q.pqp \\] . The \\(\\mathrm{and}\\) operator can be though of choosing the second parameter (\\(q\\)), if the first (\\(p\\)),is true, or choosing the first if the first is false. 1.2.2.2. Or . \\[\\mathrm{or} = \\lambda p.\\lambda q.ppq \\] . In the same vein as \\(\\mathrm{and}\\), choosing the first parameter if the first (\\(p\\)) is true, and choosing the second if \\(p\\) is false. 1.2.2.3. Not . \\[\\mathrm{not} = \\lambda p.p~\\mathrm{false~true}\\] . This simple implementation of not functions based on the idea of the booleans choosing what to return. 1.2.2.4. XOR . \\[\\mathrm{xor} = \\lambda p.\\lambda q.p (\\mathrm{not}~q)q\\] . A little fancier, but not by much. It is left as an exercise to the reader to see why this definition holds. 1.3. Predicates . From the 1.2.2 it is trivial to construct some predicates such as \\(=,\\leq,\\geq,\\) . 1.3.1. IsZero . \\[\\mathrm{IsZero}=\\lambda n.n(\\lambda x. \\mathrm{false} )~\\mathrm{true}\\] . The following predicate tests whether the first argument is less-than-or-equal-to the second: . 1.3.2. Less than or equal to . \\[\\mathrm{LEQ} :=\\lambda m . \\lambda n . \\mathrm{IsZero}~ (\\mathrm{minus}~m~n )\\] . Because of the identity, . \\[x=y \\equiv(x \\leq y \\wedge y \\leq x)\\] . 1.3.3. Equality . The test for equality may be implemented as, . \\[\\mathrm{EQ}=\\lambda m.\\lambda n.\\mathrm{and}~(\\mathrm{LEQ}~m~n)(\\mathrm{LEQ}~n~m)\\] . Footnotes: . 1 This definition of \\(\\mathrm{true}\\) may appear familiar, that is because it is \\(\\alpha\\)-equivalent to our definition or \\(0\\). It is also the \\(\\mathrm{const}\\) .",
"url": "/notes/20220225075717-church_encoding"
},"7": {
"doc":  "Binary",
"title": "Binary",
"content": "Table of Contents . | 1. Representing numbers . | 1.1. Integers . | 1.1.1. Unsigned . | 1.1.1.1. Converting binary to decimal | 1.1.1.2. Converting Decimal to Binary | 1.1.1.3. Number Range | . | . | . | . 1. Representing numbers . 1.1. Integers . 1.1.1. Unsigned . | Bit position | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | . | Value | \\(2^9\\) | \\(2^8\\) | \\(2^7\\) | \\(2^6\\) | \\(2^5\\) | \\(2^4\\) | \\(2^3\\) | \\(2^2\\) | \\(2^1\\) | \\(2^0\\) | . | &amp;#xa0; | 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . 1.1.1.1. Converting binary to decimal . Add values of each position where bit is 1 . | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | &amp;#xa0; | . | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | &amp;#xa0; | . | 128 | &amp;#xa0; | &amp;#xa0; | 16 | &amp;#xa0; | &amp;#xa0; | &amp;#xa0; | 1 | 145 | . 1.1.1.2. Converting Decimal to Binary . | Method 1 . | Rewrite \\(n\\) as sum of powers of \\(2\\) (by repeatedly subtracting largest power of \\(2\\) not greater than \\(n\\)). | Assemble binary number from \\(1\\)’s in bit positions corresponding to those powers of \\(2\\), \\(0\\)’s elsewhere | . | Method 2 – building up bits from the right (least significant) . | Divide \\(n\\) by \\(2\\) | Remainder of division (\\(0\\) or \\(1\\)) is next bit | Repeat with \\(n\\) = quotient | . | . 1.1.1.3. Number Range . For an \\(n\\)-bit word, the largest representable number is \\(2^n-1\\), e.g. \\(255\\) in this case.",
"url": "/notes/20220228214127-binary"
}
}